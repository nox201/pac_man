<!DOCTYPE html>

<html>
	<head>
		<style>
			body {
				background-color: black;
				font-family: "Lucida Console", cursive;
				font-weight: 900;
				
				
			}
			#game {
				background-color: black;
			}
			.container {
				text-align: center;
				height: 600px;
			}
			#header {
				height: 100px;
				text-align: center;
			}
			#logo {
				height: 100px;
			}
			.pacmanImage {
				height: 100px;	
			}
			.splash {
				display: none;
				position: fixed;
				margin-top: -400px;
				margin-left: 58px;
				width: 24%;
				color: white;
				background-color: black;
				border: 10px solid blue;
				border-radius: 5px;
				z-index: 1;
				font-size: 30px;
			}
			#ready {
				color: red;
			}
			#set {
				color: orange;
			}
			#go {
				color: lime;
			}
			#controls {
				text-align: center;
			}
			#gameOverText {
				font-size: 20px;
			}
			#gameArea {
				width: 34%;
				background: linear-gradient(-45deg, #ee7752, #f8ed4e, #23a6d5, #23d5ab);
				background-size: 400% 400%;
				animation: gradient 10s ease infinite;
				z-index: 1000;
				padding: 10px;
				text-align: center;
				border-radius: 20px;
			}
			@keyframes gradient {
				0% {background-position: 0% 50%;}
				50% {background-position: 100% 50%;}
				100% {background-position: 0% 50%;}
			}
			.info {
				background-color: black;
				color: yellow;
				width: 33%;
				font-size: 40px;
				margin-left: 25%;
			}
			.infoBorder {
				width: 50%;
				margin-left: 25%;
				background: linear-gradient(145deg, #000000, #000000, #FFFFFF, #000000);
				background-size: 400% 400%;
				animation: gradient 10s ease infinite;
				z-index: 1000;
				padding: 10px;
				border-radius: 8px;
			}
			.infoInterior {
				background-color: black;
			}
			
			.button {
				padding: 35px;
				border: 2px solid black;
				border-radius: 100%;
				box-shadow: 0px 0px 0px 5px yellow;
				margin-top: 20px;
				margin-bottom: 15px;
				background-color: yellow;
			}
			.button:hover {
				background: linear-gradient(145deg, #FFFF00, #FFFF00, #dbdb02, #dbdb02);
				border: 2px solid black;
			}
			.button:active:hover {
				transform: scale(0.98);
			}
			
			.easterEgg:hover {
				border: 2px solid blue;
			}
			.rotate {
				animation: rotate 10s ease infinite;
			}
			@keyframes rotate {
				0% {transform: rotate(0deg);}
				50% {transform: rotate(360deg);}
				100% {transform: rotate(0deg);}
			}
		</style>
	</head>
</html>

<body>
	<div id="header">
		<img class="pacmanImage" src="pacman.png">
		<img class="pacmanImage" src="pacman.png">
		<img class="pacmanImage" src="pacman.png">
		<img class="pacmanImage" src="pacman.png">
		<img id="logo" src="logo.png">
		<img class="pacmanImage" src="pacman-reversed.png">
		<img class="pacmanImage" src="pacman-reversed.png">
		<img class="pacmanImage" src="pacman-reversed.png">
		<img class="pacmanImage easterEgg" onclick="playEasterEgg('rotate')"src="pacman-reversed.png">
	</div>
	<div class="container">

		<table style="width: 100%">
			<tr>
				<td class="info">
					<div style="padding-left: 35px">
						<button id="startButton" class="button" onclick="handleStartButtonClicked()"></button>
						<br/>
						<span>START/PAUSE</span>
					</div>
				</td>
				<td id="gameArea">
					<canvas id="game" width="494" height="572"></canvas>
					<div id="getReadySplash" class="splash">
						<p id="ready">READY</p>
						<p id="set">SET</p>
						<p id="go">GO!</p>
					</div>
					<div id="gameOverSplash" class="splash">
						<p id="gameOverText"></p>
					</div>
				</td>
				<td class="info">
					<div class="infoBorder">
						<div class="infoInterior">
							<span class="infoText">LIVES</span>
							<br/>
							<span id="livesCounter"></span>
							<br/>
							<span>LEVEL</span>
							<br/>
							<span id="levelCounter">-</span>
							<br/>
							<span>SCORE</span>
							<br/>
							<span id="scoreCounter">-</span>
						</div>
					</div>
				</td>
			</tr>
		</table>
	</div>
	<div id="controls">
		<button onclick="startGame()">Start</button>
		<button onclick="setFrameRate('pause')">Pause</button>
		<button onclick="setFrameRate('fast')">Unpause</button>
		<button onclick="draw()">Single Frame</button>
		<button onclick="setAiMode('chase')">AI: Chase</button>
		<button onclick="setAiMode('scatter')">AI: Scatter</button>
		<button onclick="setAiMode('frightened')">AI: Frightened</button>
		<button onclick="setAiMode('atHome')">AI: At Home</button>
		<button onclick="setAiMode('goHome')">AI: Go Home</button>
		<button onclick="handleDeath()">Die</button>
		<button onclick="toggleKillable()">Swap Killable</button>
		<button onclick="toggleEnergised()">Toggle Energised</button>
	</div>
	
<!--	<canvas id="test" width="200" height="200"></canvas>
	<p>Start: <input id="testX" type="text"/></p>
	<p>End: <input id="testY" type="text"/></p>
	<button onclick="testDraw()">Test</button>-->
	
</body>

<script>
	
	//TEST CANVAS
/*	let testCanvas = document.getElementById('test');
	let testPlane = testCanvas.getContext("2d");
	function testDraw(){
		startAngle = document.getElementById('testX').value;
		endAngle = document.getElementById('testY').value;
		testPlane.clearRect(0,0,testCanvas.width,testCanvas.height);
		testPlane.beginPath();
		testPlane.arc(75,75,50,startAngle,endAngle);
		testPlane.fillStyle = '#FFF';
		testPlane.stroke();	
	}*/
	
	//BIG TO-DOs
	//inkys flank AI - DONE
	//clydes weird AI - DONE
	//ghost scatter AI - DONE
	//ghost phases - DONE
	//ghost house - DONE
	//correct pac-mans starting location - DONE
	//death + lives counter - DONE
	//resetting the game - DONE
	//engerizers - DONE
	//cookies - DONE
	//pac-man/ghost energiser running out phase - DONE
	//ghost frightened AI - DONE
	//ghost eaten AI - DONE
	//ghost frightened phase - half done, put in the worried face
	//ghost eaten phase - DONE
	//score number appear on screen when a ghost is eaten
	//in game timer - use to swap ghost ai states?
	//levels, difficulty? (I currently can't alter the speed of the sprites or pac-man without causing issues with the collision checks. Can i reduce speed and increase frame rate?
	
	//NICE-TO-HAVES:
	//styling, more flashy score display, flashing lights, bells and whistles
	//have a picture of a joystick like you'd get on a real arcade cabinet, place it underneath the lives counter and everytime the user presses a direction, update the picture so its like the user is pushing the joystick.
	//nemisis system - at the end of the game, tell the player which ghost killed them the most, and how their AI works.
	
	//BUGS 
	//ghosts can get stuck in the ghost house door when eating energisers and other situations
	//I cant change the speed of anything due to how I've made the maze - if its too fast nothing realizes it can turn a corner because there aren't enough pixels in the gap so the ghost travels past it. Can i change speed to 1 for everything but up the frame rate? And will this work given pac-man should be slightly faster than the ghosts? What I want is the ghosts to travel really fast when they've been eaten. 
	//this doesn't work - it runs fine at higher refresh rates but pac-man gets stuck in walls. 
	//AH - DO I DISCONNECT THE SPEED FROM HOW FAR AHEAD THE BOUNDS LOOKS??? GHOSTS AT 4, PAC-MAN AT 5, BUT THEY CAN MOVE 1/2/3 ETC?
	
	//SET DIRECTION CONSTANTS
	const UP = 0;
	const RIGHT = 1;
	const DOWN = 2;
	const LEFT = 3;
	const directions = ['UP', 'RIGHT', 'DOWN', 'LEFT'];
	
	//DEBUG OPTIONS
	var showDrawLoops = false;
	var drawBounds = false;
	var showCoords = false;
	var showPacmanPosition = false;
	var showSpritePosition = false;
	var showGhostPositions = false;
	var showGhostAllowedDirections = false;
	var showGhostsTargetCoords = false;
	var showKeyInputs = false;
	var showEnergisedState = true;
	
	//CANVAS
	let canvas = document.getElementById('game');
	let plane = canvas.getContext("2d");
	
	//POPUP/SPLASH VARIABLES
	let getReadySplashState = 'hidden';
	
	//GAME VARIABLES
	let state = 'gameOver';
	var score = 0;
	var direction = RIGHT;
	var speed = 5;
	var deathPhase = 0;
	var killable = true;
	var lives = 3;
	var easterEgg = '';
	var energiserState = 'none';
	var cookies = [];
	var energisers = [];
	var ghosts = []
	var eatenCombo = 1;
	
	var walls = [];
	walls.push({x:0,y:0,w:494,h:26});
	walls.push({x:0,y:26,w:26,h:182});
	walls.push({x:468,y:26,w:52,h:182});
	walls.push({x:52,y:52,w:52,h:52});
	walls.push({x:130,y:52,w:78,h:52});
	walls.push({x:234,y:26,w:26,h:78});
	walls.push({x:286,y:52,w:78,h:52});
	walls.push({x:390,y:52,w:52,h:52});
	walls.push({x:52,y:130,w:52,h:26});
	walls.push({x:130,y:130,w:26,h:130});
	walls.push({x:182,y:130,w:130,h:26});
	walls.push({x:338,y:130,w:26,h:130});
	walls.push({x:390,y:130,w:52,h:26});
	walls.push({x:234,y:156,w:26,h:52});
	walls.push({x:156,y:182,w:52,h:26});
	walls.push({x:286,y:182,w:52,h:26});
	walls.push({x:26,y:182,w:78,h:26});
	walls.push({x:390,y:182,w:78,h:26});
	walls.push({x:78,y:208,w:26,h:26});
	walls.push({x:390,y:208,w:26,h:26});
	walls.push({x:0,y:234,w:104,h:26});
	walls.push({x:390,y:234,w:104,h:26});
	//GHOST HOUSE
	walls.push({x:182,y:234,w:52,h:26});
	walls.push({x:260,y:234,w:52,h:26});
	walls.push({x:182,y:260,w:26,h:26});
	walls.push({x:286,y:260,w:26,h:26});
	walls.push({x:182,y:286,w:130,h:26});
	//END OF GHOST HOUSE
	walls.push({x:0,y:286,w:104,h:26});
	walls.push({x:130,y:286,w:26,h:78});
	walls.push({x:338,y:286,w:26,h:78});
	walls.push({x:390,y:286,w:104,h:26});
	walls.push({x:78,y:312,w:26,h:26});
	walls.push({x:390,y:312,w:26,h:26});
	walls.push({x:0,y:338,w:104,h:26});
	walls.push({x:390,y:338,w:104,h:26});
	walls.push({x:182,y:338,w:130,h:26});
	walls.push({x:234,y:364,w:26,h:52});
	walls.push({x:0,y:364,w:26,h:208});
	walls.push({x:468,y:364,w:26,h:208});
	walls.push({x:52,y:390,w:52,h:26});
	walls.push({x:130,y:390,w:78,h:26});
	walls.push({x:286,y:390,w:78,h:26});
	walls.push({x:390,y:390,w:52,h:26});
	walls.push({x:78,y:416,w:26,h:52});
	walls.push({x:390,y:416,w:26,h:52});
	walls.push({x:26,y:442,w:26,h:26});
	walls.push({x:442,y:442,w:26,h:26});
	walls.push({x:130,y:442,w:26,h:52});
	walls.push({x:338,y:442,w:26,h:52});
	walls.push({x:182,y:442,w:130,h:26});
	walls.push({x:234,y:468,w:26,h:52});
	walls.push({x:52,y:494,w:156,h:26});
	walls.push({x:286,y:494,w:156,h:26});
	walls.push({x:26,y:546,w:468,h:26});
	//GHOST HOUSE 'DOOR'
	walls.push({x:234,y:234,w:26,h:26});
	
	var pacman = {
		x: 248,
		y: 428,
		radius: 10,
		//BOUNDS HAVE DEFAULT VALUES WHICH WILL BE OVERWRITTEN AS SOON AS updatePosition IS CALLED
		bounds: {x: 30, y: 30, w: 2, h: 2},
		energised: false,
		phase: 0,
		speed: 5,
		facing: direction,
		updatePosition: function(x, y){
			this.x = x;
			this.y = y;
			this.bounds.x = x - this.radius;
			this.bounds.y = y - this.radius;
			//MINUS 1 TO THE BOUNDS ALLOWS FOR EASIER MOVEMENT, PAC-MAN DOESN'T NEED PERFECT INPUTS TO GET INTO TUNNELS
			//CAN MAKE THE GAME EASIER/HARDER BY CHANGING THESE VALUES, ALTERING THE SIZE OF THE BOUNDS, WHILE PAC-MAN STAYS THE SAME SIZE?
			this.bounds.w = this.radius * 2;
			this.bounds.h = this.radius * 2;

			switch(this.facing){
				//NORMAL MOVEMENT
				case UP: 
					this.bounds.y = this.bounds.y - speed;
				break;
				case RIGHT:
					//CHECK FOR WRAP-AROUND POSITION
					if(this.x > canvas.width){
						this.x = 0 + speed;
					}else{
						this.bounds.w = this.bounds.w + speed;
					}
				break;
				case DOWN:
					this.bounds.h = this.bounds.h + speed;
				break;
				case LEFT:
					//CHECK FOR WRAP-AROUND POSITION
					if(this.x < 0){
						this.x = canvas.width - speed;
					}else{
						this.bounds.x = this.bounds.x - speed;
					}
				break;
			}
			//DEBUG
			if(showPacmanPosition){
				console.log('this.x: ' + x + ', this.y: ' + y + ', bounds.x: ' + this.bounds.x + ', bounds.y: ' + this.bounds.y + ', bounds.w: ' + this.bounds.w + ', bounds.h: ' + this.bounds.h);
			}
			
		},
		intersects: function(rect){
			return !( rect.x > (this.bounds.x + this.bounds.w) || (rect.x + rect.w) < this.bounds.x || rect.y > (this.bounds.y + this.bounds.h) || (rect.y + rect.h) < this.bounds.y);
		},
		setBounds: function(boundsDirection){
			switch(boundsDirection){
				case UP:
					this.bounds.y = this.bounds.y - this.speed;
				break;
				case RIGHT:
					this.bounds.w = this.bounds.w + this.speed;
				break;
				case DOWN:
					this.bounds.h = this.bounds.h + this.speed;
				break;
				case LEFT:
					this.bounds.x = this.bounds.x - this.speed;
				break;
			}
		},
		resetBounds: function(boundsDirection){
			switch(boundsDirection){
				case UP:
					this.bounds.y = this.bounds.y + this.speed;
				break;
				case RIGHT:
					this.bounds.w = this.bounds.w - this.speed;
				break;
				case DOWN:
					this.bounds.h = this.bounds.h - this.speed;
				break;
				case LEFT:
					this.bounds.x = this.bounds.x + this.speed;
				break;
			}
		},
		reset: function(){
			this.x = 248;
			this.y = 428;
			this.facing = RIGHT;
			this.updatePosition(this.x, this.y);
		}
	};
	
	class Sprite {
		constructor(name, colour, x, y, radius, speed, ai, facing, phase){
			this.name = name;
			this.colour = colour;
			this.x = x;
			this.y = y;
			this.radius = radius;
			this.speed = speed;
			this.ai = ai;
			this.facing = facing;
			this.phase = phase;
		};
		name = 'default';
		colour = '#FF0000';
		x = 182;
		y = 221;
		radius = 10;
		//BOUNDS HAVE DEFAULT VALUES WHICH WILL BE OVERWRITTEN AS SOON AS updatePosition IS CALLED
		bounds = {x: 182, y: 221, w: 18, h: 18};
		phase = 0;
		speed = 4;
		state = 'normal';
		ai = 'chaser';
		facing = RIGHT;
		updatePosition = function(x, y){
			this.x = x;
			this.y = y;
			//add + 1 to the w and h properties prevents a sprite spinning in the corridors, as its exactly the right size for my 26 pixel wide corridors
			this.bounds.x = x - this.radius;
			this.bounds.y = y - this.radius;
			this.bounds.w = this.radius * 2 + 1;
			this.bounds.h = this.radius * 2 + 1;
		};
		intersects = function(rect){
			return !( rect.x > (this.bounds.x + this.bounds.w) || (rect.x + rect.w) < this.bounds.x || rect.y > (this.bounds.y + this.bounds.h) || (rect.y + rect.h) < this.bounds.y);
		};
		setBounds = function(boundsDirection){
			switch(boundsDirection){
				case UP:
					this.bounds.y = this.bounds.y - this.speed;
				break;
				case RIGHT:
					//CHECK FOR WRAP-AROUND POSITION
					if(this.x > canvas.width){
						this.x = 0 + (speed - 1);
					}else{
						this.bounds.w = this.bounds.w + this.speed;
					}
				break;
				case DOWN:
					this.bounds.h = this.bounds.h + this.speed;
				break;
				case LEFT:
					//CHECK FOR WRAP-AROUND POSITION
					if(this.x < 0){
						this.x = canvas.width - speed;
					}else{
						this.bounds.x = this.bounds.x - this.speed;
					}
				break;
			}
		};
		resetBounds = function(boundsDirection){
			switch(boundsDirection){
				case UP:
					this.bounds.y = this.bounds.y + this.speed;
				break;
				case RIGHT:
					this.bounds.w = this.bounds.w - this.speed;
				break;
				case DOWN:
					this.bounds.h = this.bounds.h - this.speed;
				break;
				case LEFT:
					this.bounds.x = this.bounds.x + this.speed;
				break;
			}
		};
		reset = function(name){
			switch(name){
				case 'blinky':
					this.ai = 'chaser';
					this.x = 273;
					this.y = 273;
					this.facing = RIGHT;
				break;
				case 'pinky':
					this.ai = 'ambush';
					this.x = 223;
					this.y = 273;
					this.facing = LEFT;				
				break;
				case 'inky':
					this.ai = 'flank';
					this.x = 248;
					this.y = 273;
					this.facing = LEFT;				
				break;
				case 'clyde':
					this.ai = 'clyde';
					this.x = 248;
					this.y = 273;
					this.facing = LEFT;				
				break;
			}
			this.ai = 'atHome';
			this.state = 'normal';
		}
	};
	
	//--
	
	//ADD KEY EVENT LISTENERS
	document.addEventListener("keydown", changeDirection);
	function changeDirection(e){
		//DEBUG
		if(showKeyInputs){
			console.log(e.code + ' pressed');
		}
		//SET DIRECTION
		switch(e.code){
			case 'KeyW':
			case 'ArrowUp':
				//BUFFER DIRECTION, WILL BE CHECKED IN movePacman()
				direction = UP;
			break;
			case 'KeyD':
			case 'ArrowRight':
				direction = RIGHT;
			break;
			case 'KeyS':
			case 'ArrowDown':
				direction = DOWN;
			break;
			case 'KeyA':
			case 'ArrowLeft':
				direction = LEFT;
			break;
			case 'Space':
				setFrameRate('pause');
			break;
			case 'Enter':
				startGame();
			break;
		}
		//console.log('current direction is ' + direction);
		
	}
	

	//--

	//DRAW FUNCTION
	function draw(){
		
		//DEBUG
		if(showDrawLoops){
			console.log('drawn');
		}
		
		//CLEAR PREVIOUS
		plane.clearRect(0,0,canvas.width,canvas.height);
		
		//DEBUG - DISPLAY PIXEL COORDINATES
		if(showCoords){
			plane.fillStyle = '#000'; 
			plane.font = '7px sans serif';
			for(i = 0; i < 494; i = i + 26){
				for(j = 0; j < 598; j = j + 26){
					console.log(i, j);
					plane.fillText(i + ',' + j, i, j);
				}
			}
		}
		
		//DRAW THE WALLS
		drawWalls();
		
		//DRAW THE COOKIES
		drawCookies();
		
		//DRAW THE ENERGISERS
		drawEnergisers();

		//MOVE PAC-MAN
		movePacman();
		//DRAW PAC-MAN
		drawPacman();
		
		//MOVE GHOSTS
		moveGhosts();
		//DRAW GHOSTS
		drawGhosts();
	
	}
	
	//--
	
	function drawWalls(){
		for(i = 0; i < walls.length; i++){
			plane.beginPath();
			plane.rect(walls[i].x, walls[i].y, walls[i].w, walls[i].h);
			plane.strokeStyle = '#FFF';
			plane.stroke();
		}
	}
	
	function drawCookies(){
		for(i = 0; i < cookies.length; i++){
			plane.beginPath();
			plane.arc(cookies[i].x, cookies[i].y, 2, 0, 6.3);
			plane.fillStyle = '#FFF';
			plane.fill();
		}
	}
	
	function drawEnergisers(){
		for(i = 0; i < energisers.length; i++){
			plane.beginPath();
			plane.arc(energisers[i].x, energisers[i].y, 5, 0, 6.3);
			plane.fillStyle = 'orange';
			plane.fill();
		}
	}
	
	//--
	
	function drawPacman(){
		//DRAW PAC-MAN
		plane.beginPath();
		switch(pacman.phase){
			case 0:
				//DIRECTION PAC-MAN IS FACING IS IRRELVANT AS ITS A CIRCLE
				plane.arc(pacman.x, pacman.y, pacman.radius, 0, 6.3);
			break;
			case 1:
			case 3:
				switch(pacman.facing){
					case UP:
						plane.arc(pacman.x, pacman.y, pacman.radius, 5.5, 3.9);
					break;
					case RIGHT:
						plane.arc(pacman.x, pacman.y, pacman.radius, 0.6, 5.6);
					break;
					case DOWN:
						plane.arc(pacman.x, pacman.y, pacman.radius, 1.1, 2, true);
					break;
					case LEFT:
						plane.arc(pacman.x, pacman.y, pacman.radius, 3.9, 2.4);
					break;
				}
			break;
			case 2:
				switch(pacman.facing){
					case UP:
						plane.arc(pacman.x, pacman.y, pacman.radius, 5.8, 3.6);
					break;
					case RIGHT:
						plane.arc(pacman.x, pacman.y, pacman.radius, 0.9, 5.3);
					break;
					case DOWN:
						plane.arc(pacman.x, pacman.y, pacman.radius, 0.7, 2.3, true);
					break;
					case LEFT:
						plane.arc(pacman.x, pacman.y, pacman.radius, 4.2, 2.1);
					break;
				}
			break;
		}
		plane.lineTo(pacman.x, pacman.y);
		if(pacman.energised){
			switch(energiserState){
				case 'on':
					switch(pacman.phase){
						case 0:
							pacmanColour = '#09ff00';
						break;
						case 1:
							pacmanColour = '#00ffe1';
						break;
						case 2:
							pacmanColour = '#0080ff';
						break;
						case 3:
							pacmanColour = '#9d00ff';
						break;
					}
				break;
				case 'runningOut':
					switch(pacman.phase){
						case 0:
							pacmanColour = '#fa4b62';
						break;
						case 1:
							pacmanColour = '#ff4a89';
						break;
						case 2:
							pacmanColour = '#ff4acf';
						break;
						case 3:
							pacmanColour = '#ffa640';
						break;
					}
				break;
			}
		}else{
			pacmanColour = '#FFFF00';
		}
		plane.fillStyle = pacmanColour;
		plane.fill();
		
		//UPDATE PAC-MANS PHASE ('ANIMATION')
		if(pacman.phase == 3){
			pacman.phase = 0;
		}else{
			pacman.phase = pacman.phase + 1;
		}
		
		//DEBUG - DRAW BOUNDS
		if(drawBounds){
			plane.rect(pacman.bounds.x, pacman.bounds.y, pacman.bounds.w, pacman.bounds.h);
			plane.fillStyle = '#EEE';
			plane.stroke();
		}
	}
	
	//This method allows buffered inputs, allowing the last direction the user pressed to be stored until pac-man can travel in that direction
	function movePacman(){
	
		//SET FLAG
		collided = false;
		
		//SET BOUNDS TO LOOK IN USER INPUT DIRECTION
		pacman.setBounds(direction);
		//ITERATE ALL WALLS
		for(i = 0; i < walls.length; i++){
			//CHECKS THE BOUNDS AGAINST THE WALL
			if(pacman.intersects(walls[i])){
				//SET FLAG
				collided = true;
				//NO NEED TO CHECK FURTHER WALLS
				break;
			}
		}
		if(!collided){
			//PAC-MAN CAN TRAVEL IN THE DESIRED DIRECTION - UPDATE THE DIRECTION HES FACING
			pacman.facing = direction;
		}
		pacman.resetBounds(direction);
		
		//--

		//SET FLAG
		collided = false;
		
		//SET BOUNDS TO LOOK IN PAC-MANS FACING DIRECTION
		pacman.setBounds(pacman.facing);
		//ITERATE ALL WALLS
		for(i = 0; i < walls.length; i++){
			//CHECKS THE BOUNDS AGAINST THE WALL
			if(pacman.intersects(walls[i])){
				//SET FLAG
				collided = true;
				//NO NEED TO CHECK FURTHER WALLS
				break;
			}
		}
		//ITERATE COOKIES
		for(i = 0; i < cookies.length; i++){
			//CHECKS THE BOUNDS - INTERSECTS EXPECTS H AND W BUT COOKIES ONLY HAVE X AND Y SO HARDCODE SMALL VALUES
			if(pacman.intersects({x: cookies[i].x, y: cookies[i].y, h: 1, w: 1})){
				//DELETE COOKIE
				cookies.splice(i, 1);
				//INCREMENT SCORE
				updateScore(10);
				//NO NEED TO CHECK FURTHER COOKIES
				break;
			}
		}
		//ITERATE ENERGISERS
		for(i = 0; i < energisers.length; i++){
			//CHECKS THE BOUNDS - INTERSECTS EXPECTS H AND W BUT ENERGISERS ONLY HAVE X AND Y SO HARDCODE SMALL VALUES
			if(pacman.intersects({x: energisers[i].x, y: energisers[i].y, h: 5, w: 5})){
				//DELETE ENERGISER
				energisers.splice(i, 1);
				//ENERGISE PAC-MAN
				if(showEnergisedState){
					console.log('pacman ate an energiser');
				}
				toggleEnergised();
				//INCREMENT SCORE
				updateScore(50);
				//NO NEED TO CHECK FURTHER ENERGISERS
				break;
			}
		}
		//CHECK FLAG
		if(!collided){
			//NO COLLISION - UPDATE PAC-MANS POSITION
			switch(pacman.facing){
				case UP:
					pacman.updatePosition(pacman.x, pacman.y - pacman.speed);
				break;
				case RIGHT:
					pacman.updatePosition(pacman.x + pacman.speed, pacman.y);
				break;
				case DOWN:
					pacman.updatePosition(pacman.x, pacman.y + pacman.speed);
				break;
				case LEFT:
					pacman.updatePosition(pacman.x - pacman.speed, pacman.y);
				break;
			}
		}
		//RESET BOUNDS
		pacman.resetBounds(pacman.facing);
		
	}
	
	//--
		
	function drawGhosts(){
		//ITERATE GHOSTS
		for(i = 0; i < ghosts.length; i++){
			//TO-DO - ghosts phases

			plane.beginPath();
			plane.arc(ghosts[i].x, ghosts[i].y, ghosts[i].radius, 0, Math.PI, true); 
			plane.lineTo((ghosts[i].x - ghosts[i].radius), ghosts[i].y);
			//plane.lineTo((ghosts[i].x - ghosts[i].radius), (ghosts[i].y + ghosts[i].radius + 2));
			switch(ghosts[i].phase){
				case 0:
					plane.lineTo((ghosts[i].x - ghosts[i].radius), (ghosts[i].y + ghosts[i].radius + 2));
					plane.lineTo((ghosts[i].x - ghosts[i].radius + 4), (ghosts[i].y + ghosts[i].radius - 2));
					plane.lineTo((ghosts[i].x - ghosts[i].radius + 7), (ghosts[i].y + ghosts[i].radius + 2));
					plane.lineTo((ghosts[i].x - ghosts[i].radius + 9), (ghosts[i].y + ghosts[i].radius - 2));
					plane.lineTo((ghosts[i].x - ghosts[i].radius + 12), (ghosts[i].y + ghosts[i].radius + 2));
					plane.lineTo((ghosts[i].x - ghosts[i].radius + 15), (ghosts[i].y + ghosts[i].radius - 2));
					plane.lineTo((ghosts[i].x - ghosts[i].radius + 20), (ghosts[i].y + ghosts[i].radius + 2));
					if(ghosts[i].ai == 'frightened'){
						plane.fillStyle = 'blue';
					}else{
						plane.fillStyle = ghosts[i].colour;
					}
				break;
				case 1:
					plane.lineTo((ghosts[i].x - ghosts[i].radius), (ghosts[i].y + ghosts[i].radius));
					plane.lineTo((ghosts[i].x - ghosts[i].radius + 4), (ghosts[i].y + ghosts[i].radius + 2));
					plane.lineTo((ghosts[i].x - ghosts[i].radius + 7), (ghosts[i].y + ghosts[i].radius - 2));
					plane.lineTo((ghosts[i].x - ghosts[i].radius + 9), (ghosts[i].y + ghosts[i].radius + 2));
					plane.lineTo((ghosts[i].x - ghosts[i].radius + 12), (ghosts[i].y + ghosts[i].radius - 2));
					plane.lineTo((ghosts[i].x - ghosts[i].radius + 15), (ghosts[i].y + ghosts[i].radius + 2));
					plane.lineTo((ghosts[i].x - ghosts[i].radius + 20), (ghosts[i].y + ghosts[i].radius - 2));
					if(ghosts[i].ai == 'frightened'){
						if(energiserState == 'runningOut'){
							plane.fillStyle = 'black';
						}else{
							plane.fillStyle = 'blue';
						}
					}else{
						plane.fillStyle = ghosts[i].colour;
					}
				break;
			}
			//DONT DRAW GHOST BODIES WHEN THEYVE BEEN EATEN
			if(ghosts[i].state != 'eaten'){
				plane.fill();
			}
			
			//UPDATE GHOSTS PHASE ('ANIMATION')
			if(ghosts[i].phase == 1){
				ghosts[i].phase = 0;
			}else{
				ghosts[i].phase = ghosts[i].phase + 1;
			}
			
			//DRAW EYES
			if(ghosts[i].state == 'eaten'){
				plane.fillStyle = 'white';
			}else{
				plane.fillStyle = 'white';
			}
			plane.beginPath();
			plane.arc(ghosts[i].x - 5, ghosts[i].y - 5, 4, 0, Math.PI * 2);
			plane.fill();
			plane.beginPath();
			plane.arc(ghosts[i].x + 5, ghosts[i].y - 5, 4, 0, Math.PI * 2);
			plane.fill();
			//DRAW PUPILS
			if(ghosts[i].state == 'eaten'){
				plane.fillStyle = 'grey';
			}else{
				plane.fillStyle = 'blue';
			}	
			plane.beginPath();
			switch(ghosts[i].facing){
				case UP:
					plane.arc(ghosts[i].x - 5, ghosts[i].y - 8, 2, 0, Math.PI * 2);
					plane.fill();
					plane.beginPath();
					plane.arc(ghosts[i].x + 5, ghosts[i].y - 8, 2, 0, Math.PI * 2);
				break;
				case RIGHT:
					plane.arc(ghosts[i].x - 2, ghosts[i].y - 5, 2, 0, Math.PI * 2);
					plane.fill();
					plane.beginPath();
					plane.arc(ghosts[i].x + 8, ghosts[i].y - 5, 2, 0, Math.PI * 2);
				break;
				case DOWN:
					plane.arc(ghosts[i].x - 5, ghosts[i].y - 2, 2, 0, Math.PI * 2);
					plane.fill();
					plane.beginPath();
					plane.arc(ghosts[i].x + 5, ghosts[i].y - 2, 2, 0, Math.PI * 2);
				break;
				case LEFT:
					plane.arc(ghosts[i].x - 8, ghosts[i].y - 5, 2, 0, Math.PI * 2);
					plane.fill();
					plane.beginPath();
					plane.arc(ghosts[i].x + 2, ghosts[i].y - 5, 2, 0, Math.PI * 2);
				break;
			}
			plane.fill();

			//DEBUG - DRAW BOUNDS
			if(drawBounds){
				plane.rect(ghosts[i].bounds.x, ghosts[i].bounds.y, ghosts[i].bounds.w, ghosts[i].bounds.h);
				plane.fillStyle = '#EEE';
				plane.stroke();
			}
		}
	}
	
	//--
	
	function moveGhosts(){
		//ITERATE GHOSTS
		for(i = 0; i < ghosts.length; i++){
	
			//INIT VALUES
			let collidedWalls = [];
			let allowedDirections = [UP, RIGHT, DOWN, LEFT];
			let skip;
			
			//SET POSSIBLE DIRECTIONS - GHOSTS CANNOT TURN AROUND
			switch(ghosts[i].facing){
				case UP:
					skip = DOWN;
				break;
				case LEFT:
					skip = RIGHT;
				break;
				case DOWN:
					skip = UP;
				break;
				case RIGHT:
					skip = LEFT;
				break;
			}

			//ITERATE ALL DIRECTIONS
			for(pd = 0; pd < directions.length; pd++){
				//CHECK DIRECTION
				if(pd == skip){
					//REMOVE FROM ALLOWED DIRECTIONS
					allowedDirections = allowedDirections.filter(function(e) { return e != pd });
					//SKIP 'REVERSE' DIRECTION
					continue;
				}
				
				//SET BOUNDS TO LOOK IN ATTEMPTED DIRECTION
				ghosts[i].setBounds(pd);
				
				//CHECK WALLS
				for(w = 0; w < walls.length; w++){
					//IGNORE FINAL WALL (GHOST HOUSE DOOR) IN SOME CASES
					if((w == walls.length - 1) && (ghosts[i].ai == 'goHome' || ghosts[i].ai == 'atHome')){
						continue;
					}
					//CHECKS THE BOUNDS AGAINST THE WALL
					if(ghosts[i].intersects(walls[w])){
						//DEBUG
						//console.log('ghost ' + directions[pd] + ' check intersected wall ' + w + ' at ' + walls[w]);
						//REMOVE FROM ALLOWED DIRECTIONS
						allowedDirections = allowedDirections.filter(function(e) { return e != pd });
						//NO NEED TO CHECK FURTHER WALLS
						break;
					}
				}
				
				//CHECK PAC-MAN
				if(ghosts[i].intersects(pacman.bounds)){
					if(pacman.energised){
						if(ghosts[i].state != 'eaten'){
							//EAT GHOST
							ghosts[i].state = 'eaten';
							ghosts[i].ai = 'goHome';
							//ADD SCORE
							updateScore(200 * eatenCombo);
							//INCREMENT EATEN COMBO
							eatenCombo++;
						}
					}else if(ghosts[i].state == 'eaten'){
						//DO NOTHING
						
					}else{
						if(killable){
							//DIE
							handleDeath();
							return;
						}
					}
				}
				//RESET BOUNDS
				ghosts[i].resetBounds(pd);
			}
			
			//DEBUG - SHOWS WHICH DIRECTIONS THE GHOST IS ALLOWED TO TRAVEL
			if(showGhostAllowedDirections){
				console.log('ghosts allowed directions:');
				console.log(allowedDirections);
				if(allowedDirections.length == 0){
					console.log('GHOST STUCK!');
				}
			}
			
			if(allowedDirections.length == 0){
				switch(ghosts[i].facing){
					case UP:
						ghosts[i].facing = DOWN;
					break;
					case RIGHT:
						ghosts[i].facing = LEFT;
					break;
					case DOWN:
						ghosts[i].facing = UP;
					break;
					case LEFT:
						ghosts[i].facing = RIGHT;
					break;
				}
			}
			
			//GHOST IS TO CONTINUE IN THE SAME DIRECTION
			directionTo = ghosts[i].facing;
			
			//INIT SHORTEST DIRECTION, SET TO IMPOSSIBLY LARGE DISTANCE
			shortestDistance = 1000;
			
			//ONLY RUN DECISION MAKING IF THERE IS A CHOICE OF DIRECTIONS
			//this has been commented as it causes an issue in right angles - allowedDirections still only has one option, but its
			//changed from the direction the ghost is facing, however I don't run the ai, causing the ghost to continue travelling
			//straight when he hits a right angle. But this could be a possible optimization if i get performance issues
			//if(allowedDirections.length > 1){
			
			//SET DESTINATION POINT
			switch(ghosts[i].ai){
				case 'atHome':
					destinationX = 248;
					destinationY = 223;
				break;
				case 'goHome':
					destinationX = 248;
					destinationY = 278;
				break;
				case 'chaser':
					destinationX = pacman.x;
					destinationY = pacman.y;
				break;
				case 'ambush':
					//THE ORIGINAL ARCADE PAC-MAN AI INTENDS THE DESTINATION POINT TO BE INFRONT OF PACMAN, HOWEVER DUE TO A BUG, ITS CALCULATED AS ABOVE AND TO THE LEFT
					//I HAVE REPLICATED THIS BEHAVIOUR BECAUSE WHY NOT
					switch(pacman.facing){
						case UP:
							destinationX = pacman.x - pacman.radius * 4;
							destinationY = pacman.y - pacman.radius * 4;
						break;
						case RIGHT:
							destinationX = pacman.x + pacman.radius * 4;
							destinationY = pacman.y - pacman.radius * 4;
						break;
						case DOWN:
							destinationX = pacman.x + pacman.radius * 4;
							destinationY = pacman.y + pacman.radius * 4;
						break;
						case LEFT:
							destinationX = pacman.x - pacman.radius * 4;
							destinationY = pacman.y + pacman.radius * 4;
						break;
					}
				break;
				case 'flank':
					//THIS AI DRAWS A LINE BETWEEN BLINKY AND PAC-MAN, THEN EXTENDS IT PAST PAC-MAN THE SAME DISTANCE
					//CALCULATE ANGLE OF LINE BETWEEN BLINKY AND PAC-MAN, IN RADIANS
					var angle = Math.atan2((pacman.y - ghosts[0].y), (pacman.x - ghosts[0].x));

					//CALCULATE DISTANCE BETWEEN BLINKY AND PAC-MAN
					var distance = Math.hypot(pacman.x - ghosts[0].x, pacman.y - ghosts[0].y);

					//SET DESTINATION
					destinationX = pacman.x + distance * Math.cos(angle);
					destinationY = pacman.y + distance * Math.sin(angle);
				break;
				case 'clyde':
					//CALCULATE DISTANCE BETWEEN CLYDE AND PAC-MAN
					var distance = Math.hypot(pacman.x - ghosts[3].x, pacman.y - ghosts[3].y);
					//CHECK DISTANCE - AROUND 8 TILES
					if(distance > 208){
						//HEAD TOWARDS PACMAN
						destinationX = pacman.x;
						destinationY = pacman.y;
					}else{
						//HEAD TOWARDS BOTTOM LEFT
						destinationX = 38;
						destinationY = 533;
					}
				break;
				case 'scatter':
					switch(ghosts[i].name){
						case 'blinky':
							//TOP LEFT
							destinationX = 38;
							destinationY = 38;
						break;
						case 'pinky':
							//TOP RIGHT
							destinationX = 453;
							destinationY = 38;
						break;
						case 'inky':
							//BOTTOM RIGHT
							destinationX = 453;
							destinationY = 533;
						break;
						case 'clyde':
							//BOTTOM LEFT
							destinationX = 38;
							destinationY = 533;
						break;
					}
				break;
			}
			
			//DEBUG
			if(showGhostsTargetCoords){
				//DRAW A CIRCLE WHERE THE GHOSTS ARE ATTEMPTING TO GO
				plane.beginPath();
				plane.arc(destinationX, destinationY, ghosts[i].radius - 5, 0, 2 * Math.PI); 
				plane.strokeStyle = ghosts[i].colour;
				plane.stroke();
			}
			
			//CHECK IF GHOST HAS REACHED TARGET POINT FOR SET AIS
			if(ghosts[i].ai == 'goHome'){
				//CHECK IF GHOST REACHES TARGET DESTINATION
				if(ghosts[i].x >= 223 && ghosts[i].x <= 273 && ghosts[i].y >= 270 && ghosts[i].y <= 276){
					ghosts[i].state = 'normal';
					ghosts[i].ai = 'atHome';
				}
			}
			if(ghosts[i].ai == 'atHome'){
				//CHECK IF GHOST REACHES TARGET DESTINATION
				if(ghosts[i].x >= 240 && ghosts[i].x <= 253 && ghosts[i].y >= 220 && ghosts[i].y <= 226){
					switch(ghosts[i].name){
						case 'blinky':
							ghosts[i].ai = 'chaser';
						break;
						case 'pinky':
							ghosts[i].ai = 'ambush';
						break;
						case 'inky':
							ghosts[i].ai = 'flank';
						break;
						case 'clyde':
							ghosts[i].ai = 'clyde';
						break;
					}
				}
			
			}
			
			//DEBUG
			if(showGhostPositions){
				console.log(ghosts[i].name + ' is at x: ' + ghosts[i].x + ', y: ' + ghosts[i].y);
			}
			
			//CHANGE BASED ON GHOST AI
			switch(ghosts[i].ai){
				//AIS THAT USE A DESTINATION POINT
				case 'atHome':
				case 'goHome':
				case 'chaser':
				case 'ambush':
				case 'flank':
				case 'clyde':
				case 'scatter':
					for(ad = 0; ad < allowedDirections.length; ad++){
						switch(allowedDirections[ad]){
							case UP:
								len = getLength(ghosts[i].x, ghosts[i].y - ghosts[i].radius, destinationX, destinationY);
								if(len < shortestDistance){
									directionTo = UP;
									shortestDistance = len;
								}
							break;
							case RIGHT:
								len = getLength(ghosts[i].x + ghosts[i].radius, ghosts[i].y, destinationX, destinationY);
								if(len < shortestDistance){
									directionTo = RIGHT;
									shortestDistance = len;
								}
							break;
							case DOWN:
								len = getLength(ghosts[i].x, ghosts[i].y + ghosts[i].radius, destinationX, destinationY);
								if(len < shortestDistance){
									directionTo = DOWN;
									shortestDistance = len;
								}
							break;
							case LEFT:
								len = getLength(ghosts[i].x - ghosts[i].radius, ghosts[i].y, destinationX, destinationY);
								if(len < shortestDistance){
									directionTo = LEFT;
									shortestDistance = len;
								}
							break;
						}
					}
				break;
				//PICK A RANDOM DIRECTION WHEN POSSIBLE
				case 'frightened':
					if(allowedDirections.length >= 1){
						directionTo = allowedDirections[Math.floor(Math.random() * allowedDirections.length)];
					}
				break;
				
			}
			
			//SET FACING
			ghosts[i].facing = directionTo;
			
			//DEBUG - SHOWS WHICH DIRECTIONS THE GHOST IS ALLOWED TO TRAVEL
			if(showGhostAllowedDirections){
				console.log('Ghosts direction to is: ' + directions[directionTo]);
			}
			//DEBUG
			if(showSpritePosition){
				console.log(ghosts[i].name + ' - x: ' + ghosts[i].x + ', y: ' + ghosts[i].y + ', bounds.x: ' + ghosts[i].bounds.x + ', bounds.y: ' + ghosts[i].bounds.y + ', bounds.w: ' + ghosts[i].bounds.w + ', bounds.h: ' + ghosts[i].bounds.h);
			}
			
			//MOVE GHOST
			switch(ghosts[i].facing){
				case UP:
					ghosts[i].updatePosition(ghosts[i].x, ghosts[i].y - ghosts[i].speed);
					ghosts[i].facing = UP;
				break;
				case RIGHT:
					//CHECK FOR WRAP-AROUND TUNNEL, GHOSTS TRAVEL SLOWER THROUGH IT
					//pretty sure theres a bug here, the ghosts sometimes don't appear to slow down
					if((ghosts[i].x > 403 || ghosts[i].x < 88) && ghosts[i].y == 273){
						ghosts[i].updatePosition(ghosts[i].x + (ghosts[i].speed - 1), ghosts[i].y);
					}else{
						ghosts[i].updatePosition(ghosts[i].x + ghosts[i].speed, ghosts[i].y);
					}
					ghosts[i].facing = RIGHT;
				break;
				case DOWN:
					ghosts[i].updatePosition(ghosts[i].x, ghosts[i].y + ghosts[i].speed);
					ghosts[i].facing = DOWN;
				break;
				case LEFT:
					//CHECK FOR WRAP-AROUND TUNNEL, GHOSTS TRAVEL SLOWER THROUGH IT
					//pretty sure theres a bug here, the ghosts sometimes don't appear to slow down
					if((ghosts[i].x < 88 || ghosts[i].x < 403) && ghosts[i].y == 273){
						ghosts[i].updatePosition(ghosts[i].x - (ghosts[i].speed - 1), ghosts[i].y);
					}else{
						ghosts[i].updatePosition(ghosts[i].x - ghosts[i].speed, ghosts[i].y);
					}
					ghosts[i].facing = LEFT;
				break;
			}
		
		}
		
	
	}
	
	//--
	
	//MINOR UTILITY GAME FUNCTIONS
	function turnGhostsAround(option)
	{
		for(g = 0; g < ghosts.length; g++){
			if(option == ghosts[g].name || option == 'all'){
				switch(ghosts[g].facing){
					case UP:
						ghosts[g].facing = DOWN;
					break;
					case RIGHT:
						ghosts[g].facing = LEFT;
					break;
					case DOWN:
						ghosts[g].facing = UP;
					break;
					case LEFT:
						ghosts[g].facing = RIGHT;
					break;
				}
			}
		}
	}
	
	//THIS FUNCTION ALLOWS FOR THE CREATION OF GHOSTS TO BE STAGGERED AFTER THE LEVEL STARTS, MAKING SURE THE PLAYER ISNT SWARMED BY ALL THE GHOSTS AT ONCE
	function spawnGhosts()
	{
		//console.log('spawn ghosts called');
		let keepSpawning = false;
		//CHECK NUMBER OF GHOSTS
		switch(ghosts.length){
			case 0:
				ghosts.push(new Sprite('blinky', '#FF0000', 273, 273, 10, 4, 'atHome', RIGHT, 0));
				keepSpawning = true;
			break;
			case 1:
				ghosts.push(new Sprite('pinky', '#fc9ff9', 223, 273, 10, 4, 'atHome', LEFT, 1));
				keepSpawning = true;
			break;
			case 2:
				ghosts.push(new Sprite('inky', '#00fff2', 248, 273, 10, 4, 'atHome', LEFT, 0));
				keepSpawning = true;
			break;
			case 3:
				ghosts.push(new Sprite('clyde', '#fcba03', 248, 273, 10, 4, 'atHome', LEFT, 1));
				keepSpawning = false;
			break;
			case 4:
				keepSpawning = false;
			break;
		}
		if(keepSpawning){
			window.setTimeout(spawnGhosts, 2000);
		}
	}
	
	function toggleKillable()
	{
		killable = !killable;
		console.log('Killable: ' + killable);
	}
	
	function handleDeath()
	{
		//PAUSE GAME
		setFrameRate('pause');
		
		//PLAY DEATH ANIMATION
		playDeathAnimation();
		
		//DECREMENT LIVES
		lives--;
		updateLivesCounter(lives);
		console.log('lives: ' + lives);
		if(lives < 0){
			gameOver();
			return;
		}
		
		//RESET GAME
		setTimeout(startGame, 2500);
	}
	
	function playDeathAnimation()
	{
		//DEFINE ARC RADIANS
		let radians = [];
		radians[UP] = [];
		radians[UP][0] = [5.5, 3.9];
		radians[UP][1] = [5.9, 3.5];
		radians[UP][2] = [6.3, 3.1];
		radians[UP][3] = [6.7, 2.7];
		radians[UP][4] = [7.1, 2.3];
		radians[UP][5] = [7.5, 1.9];
		radians[RIGHT] = [];
		radians[RIGHT][0] = [0.6, 5.6];
		radians[RIGHT][1] = [1, 5.2];
		radians[RIGHT][2] = [1.4, 4.8];
		radians[RIGHT][3] = [1.8, 4.4];
		radians[RIGHT][4] = [2.2, 4];
		radians[RIGHT][5] = [2.6, 3.6];
		radians[DOWN] = [];
		radians[DOWN][0] = [2.4, 0.7];
		radians[DOWN][1] = [2.8, 0.3];
		radians[DOWN][2] = [3.2, 6.2];
		radians[DOWN][3] = [3.6, 5.8];
		radians[DOWN][4] = [4, 5.4];
		radians[DOWN][5] = [4.4, 5];
		radians[LEFT] = [];
		radians[LEFT][0] = [3.9, 2.4];
		radians[LEFT][1] = [4.3, 2];
		radians[LEFT][2] = [4.7, 1.6];
		radians[LEFT][3] = [5.1, 1.2];
		radians[LEFT][4] = [5.5, 0.8];
		radians[LEFT][5] = [5.9, 0.4];
		
		//CLEAR PREVIOUS
		plane.clearRect(0,0,canvas.width,canvas.height);
		//DRAW WALLS
		drawWalls();
		
		if(deathPhase < 6){
			//DRAW PAC-MAN
			plane.beginPath();
			plane.arc(pacman.x, pacman.y, pacman.radius, radians[pacman.facing][deathPhase][0], radians[pacman.facing][deathPhase][1]);
			plane.lineTo(pacman.x, pacman.y);
			plane.fillStyle = '#FFFF00';
			plane.fill();
		}else{
			//to-do - finish this starburst effect
			plane.fillStyle = '#FFFF00';
			plane.beginPath();
			plane.moveTo(pacman.x, pacman.y);
			plane.lineTo(pacman.x -5, pacman.y - 5);
			plane.stroke();
			plane.moveTo(pacman.x, pacman.y);
			plane.lineTo(pacman.x -5, pacman.y);
			plane.stroke();
			plane.moveTo(pacman.x, pacman.y);
			plane.lineTo(pacman.x -5, pacman.y + 5);
			plane.stroke();
			plane.moveTo(pacman.x, pacman.y);
			plane.lineTo(pacman.x, pacman.y + 5);
			plane.stroke();
			plane.moveTo(pacman.x, pacman.y);
			plane.lineTo(pacman.x, pacman.y - 5);
			plane.stroke();
			plane.moveTo(pacman.x, pacman.y);
			plane.lineTo(pacman.x + 5, pacman.y - 5);
			plane.stroke();
			plane.moveTo(pacman.x, pacman.y);
			plane.lineTo(pacman.x + 5, pacman.y);
			plane.stroke();
			plane.moveTo(pacman.x, pacman.y);
			plane.lineTo(pacman.x + 5, pacman.y + 5);
			plane.stroke();
		}
		
		//RESET DEATH ANIMATION COUNTER
		if(deathPhase == 7){
			deathPhase = 0;
		}else{
			//INCREMENT PHASE
			deathPhase++;
			//WAIT THEN DO NEXT FRAME
			setTimeout(playDeathAnimation, 200);
		}

	}
	
	//--
	
	function toggleEnergised()
	{
		if(showEnergisedState){
			console.log('toggleEnergised called');
		}
		switch(energiserState){
			case 'none':				
				//TOGGLE PAC-MAN ENERGISED STATE
				pacman.energised = true;
				//SET GHOSTS AI
				setAiMode('frightened');
				//UPDATE ENERGISER STATE
				energiserState = 'on';
				//CALL FUNCTION AGAIN
				window.setTimeout(toggleEnergised, 5000);
			break;
			case 'on':
				//TOGGLE PAC-MAN ENERGISED STATE
				pacman.energised = true;
				//UPDATE ENERGISER STATE
				energiserState = 'runningOut';
				//CALL FUNCTION AGAIN
				window.setTimeout(toggleEnergised, 3000);
			break;
			case 'runningOut':
				//TOGGLE PAC-MAN ENERGISED STATE
				pacman.energised = false;
				//UPDATE ENERGISER STATE
				energiserState = 'none';
				//SET GHOSTS AI
				setAiMode('chase');
				//RESET EATEN COMBO
				eatenCombo = 1;
			break;
		}
		if(showEnergisedState){
			console.log('Energised: ' + pacman.energised + ', energiserState: ' + energiserState);
		}
	}
	
	function setAiMode(mode)
	{
		//GHOSTS TURN AROUND - will this happen on every AI switch? maybe not when switching to eaten mode? 
		//but then can just move this call into the switch block
		turnGhostsAround('all');
		
		for(i = 0; i < ghosts.length; i++){
			//IGNORE AI CHANGES FOR EATEN GHOSTS, THEIR AI WILL BE UPDATED WHEN THEY GET TO THE GHOST HOUSE
			//THIS PREVENTS ISSUES WITH GHOSTS BECOMING STUCK IN EATEN OR FRIGHTENED STATES WHEN THE ENGERGISER STATE CHANGES
			if(ghosts[i].ai != 'goHome'){
				//CHASE AI IS GHOST SPECIFIC
				if(mode == 'chase'){
					switch(ghosts[i].name){
						case 'blinky':
							ghosts[i].ai = 'chaser';
						break;
						case 'pinky':
							ghosts[i].ai = 'ambush';
						break;
						case 'inky':
							ghosts[i].ai = 'flank';
						break;
						case 'clyde':
							ghosts[i].ai = 'clyde';
						break;
					}
				}else{
					//SET ALL GHOSTS AI TO MODE
					ghosts[i].ai = mode;
				}
			}
		}
	}
	
	function resetEnergisers()
	{
		//EMPTY EXISTING ENERGISERS
		energisers = [];
		energisers.push({x:38,y:90});
		energisers.push({x:453,y:90});
		energisers.push({x:38,y:428});
		energisers.push({x:453,y:428});
	}
	
	//THIS FUNCTION COULD BE REWRITTEN TO ITERATE X AND Y COORDS IN INCREMENTS OF 26, AND THEN CHECK AGAINST AN ARRAY OF LOCATIONS THAT DON'T HAVE COOKIES
	//PROBABLY WOULD TAKE A LOT LESS LINES
	function resetCookies()
	{
		//EMPTY EXISTING COOKIES
		cookies = [];
		cookies.push({x:38,y:38});
		cookies.push({x:64,y:38});
		cookies.push({x:90,y:38});
		cookies.push({x:116,y:38});
		cookies.push({x:142,y:38});
		cookies.push({x:168,y:38});
		cookies.push({x:194,y:38});
		cookies.push({x:220,y:38});
		cookies.push({x:272,y:38});
		cookies.push({x:298,y:38});
		cookies.push({x:324,y:38});
		cookies.push({x:350,y:38});
		cookies.push({x:376,y:38});
		cookies.push({x:402,y:38});
		cookies.push({x:428,y:38});
		cookies.push({x:453,y:38});
		cookies.push({x:38,y:64});
		cookies.push({x:116,y:64});
		cookies.push({x:220,y:64});
		cookies.push({x:272,y:64});
		cookies.push({x:376,y:64});
		cookies.push({x:453,y:64});
		//cookies.push({x:38,y:90});
		cookies.push({x:116,y:90});
		cookies.push({x:220,y:90});
		cookies.push({x:272,y:90});
		cookies.push({x:376,y:90});
		//cookies.push({x:453,y:90});
		cookies.push({x:38,y:116});
		cookies.push({x:64,y:116});
		cookies.push({x:90,y:116});
		cookies.push({x:116,y:116});
		cookies.push({x:142,y:116});
		cookies.push({x:168,y:116});
		cookies.push({x:194,y:116});
		cookies.push({x:220,y:116});
		cookies.push({x:246,y:116});
		cookies.push({x:272,y:116});
		cookies.push({x:298,y:116});
		cookies.push({x:324,y:116});
		cookies.push({x:350,y:116});
		cookies.push({x:376,y:116});
		cookies.push({x:402,y:116});
		cookies.push({x:428,y:116});
		cookies.push({x:453,y:116});
		cookies.push({x:38,y:142});
		cookies.push({x:116,y:142});
		cookies.push({x:168,y:142});
		cookies.push({x:324,y:142});
		cookies.push({x:376,y:142});
		cookies.push({x:453,y:142});
		cookies.push({x:38,y:168});
		cookies.push({x:64,y:168});
		cookies.push({x:90,y:168});
		cookies.push({x:116,y:168});
		cookies.push({x:168,y:168});
		cookies.push({x:194,y:168});
		cookies.push({x:220,y:168});
		cookies.push({x:272,y:168});
		cookies.push({x:298,y:168});
		cookies.push({x:324,y:168});
		cookies.push({x:376,y:168});
		cookies.push({x:402,y:168});
		cookies.push({x:428,y:168});
		cookies.push({x:453,y:168});
		cookies.push({x:116,y:194});
		cookies.push({x:376,y:194});
		cookies.push({x:116,y:220});
		cookies.push({x:376,y:220});
		cookies.push({x:116,y:246});
		cookies.push({x:376,y:246});
		cookies.push({x:116,y:272});
		cookies.push({x:376,y:272});
		cookies.push({x:116,y:298});
		cookies.push({x:376,y:298});
		cookies.push({x:116,y:324});
		cookies.push({x:376,y:324});
		cookies.push({x:116,y:350});
		cookies.push({x:376,y:350});
		cookies.push({x:38,y:376});
		cookies.push({x:64,y:376});
		cookies.push({x:90,y:376});
		cookies.push({x:116,y:376});
		cookies.push({x:142,y:376});
		cookies.push({x:168,y:376});
		cookies.push({x:194,y:376});
		cookies.push({x:220,y:376});
		cookies.push({x:272,y:376});
		cookies.push({x:298,y:376});
		cookies.push({x:324,y:376});
		cookies.push({x:350,y:376});
		cookies.push({x:376,y:376});
		cookies.push({x:402,y:376});
		cookies.push({x:428,y:376});
		cookies.push({x:453,y:376});
		cookies.push({x:38,y:402});
		cookies.push({x:116,y:402});
		cookies.push({x:220,y:402});
		cookies.push({x:272,y:402});
		cookies.push({x:376,y:402});
		cookies.push({x:453,y:402});
		//cookies.push({x:38,y:428});
		cookies.push({x:64,y:428});
		cookies.push({x:116,y:428});
		cookies.push({x:142,y:428});
		cookies.push({x:168,y:428});
		cookies.push({x:194,y:428});
		cookies.push({x:220,y:428});
		cookies.push({x:272,y:428});
		cookies.push({x:298,y:428});
		cookies.push({x:324,y:428});
		cookies.push({x:350,y:428});
		cookies.push({x:376,y:428});
		cookies.push({x:428,y:428});
		//cookies.push({x:453,y:428});
		cookies.push({x:64,y:453});
		cookies.push({x:116,y:453});
		cookies.push({x:168,y:453});
		cookies.push({x:324,y:453});
		cookies.push({x:376,y:453});
		cookies.push({x:428,y:453});
		cookies.push({x:38,y:479});
		cookies.push({x:64,y:479});
		cookies.push({x:90,y:479});
		cookies.push({x:116,y:479});
		cookies.push({x:168,y:479});
		cookies.push({x:194,y:479});
		cookies.push({x:220,y:479});
		cookies.push({x:272,y:479});
		cookies.push({x:298,y:479});
		cookies.push({x:324,y:479});
		cookies.push({x:376,y:479});
		cookies.push({x:402,y:479});
		cookies.push({x:428,y:479});
		cookies.push({x:453,y:479});
		cookies.push({x:38,y:504});
		cookies.push({x:220,y:504});
		cookies.push({x:272,y:504});
		cookies.push({x:453,y:504});
		cookies.push({x:38,y:533});
		cookies.push({x:64,y:533});
		cookies.push({x:90,y:533});
		cookies.push({x:116,y:533});
		cookies.push({x:142,y:533});
		cookies.push({x:168,y:533});
		cookies.push({x:194,y:533});
		cookies.push({x:220,y:533});
		cookies.push({x:246,y:533});
		cookies.push({x:272,y:533});
		cookies.push({x:298,y:533});
		cookies.push({x:324,y:533});
		cookies.push({x:350,y:533});
		cookies.push({x:376,y:533});
		cookies.push({x:402,y:533});
		cookies.push({x:428,y:533});
		cookies.push({x:453,y:533});
	}
	
	
	
	//--
	
	function getLength(p1x, p1y, p2x, p2y)
	{
		var x = p2x - p1x;
		x = x * x;
		var y = p2y - p1y;
		y = y * y;
		return Math.sqrt(x + y);
	}

	//--
	
	//SET FRAME RATE (ALSO DOUBLES AS DIFFICULTY)
	function setFrameRate(frameRate)
	{
		//STOP CURRENT REPEATER
		if(typeof repeater !== 'undefined'){
			clearInterval(repeater);
		}
		//RUN THE CANVAS
		switch(frameRate){
			case 'pause':
				if(typeof repeater !== 'undefined'){
					clearInterval(repeater);
				}
			break;
			case 'slow':
				repeater = setInterval(draw, 200);
			break;
			case 'medium':
				repeater = setInterval(draw, 100);
			break;
			case 'fast':
				repeater = setInterval(draw, 60);
			break;
			case 'destroy':
				repeater = setInterval(draw, 25);
			break;
		}
	}
	
	//--
	
	function handleStartButtonClicked()
	{
		//BUTTON STUFF
	
	
		//CHECK GAME STATE - WILL START/PAUSE 
		if(state == 'play'){
			//PAUSE GAME
			state = 'paused';
			setFrameRate('paused');
		}else if(state == 'gameOver'){
			//START NEW GAME
			newGame();
		}else{
			//UNPAUSE GAME
			state = 'play';
			setFrameRate('fast');
		}
	
	}
	
	//CALL THIS TO CLEAR THE BOARD, START A NEW GAME
	function newGame()
	{
	
		//REMOVE GAME OVER SPLASH
		document.getElementById('gameOverSplash').style.display = 'none';
		
		//CLEAR CANVAS
		plane.clearRect(0,0,canvas.width,canvas.height);

		//RESET LIVES
		lives = 3;
		updateLivesCounter(lives);
		
		//RESET COOKIES
		resetCookies();
		//RESET ENERGISERS
		resetEnergisers();
		
		//RESET SCORE
		updateScore(-score);
		
		//RESET LEVEL
		
		//START GAME
		startGame(0);
	}
	
	function startGame(level)
	{
		//SET STATE
		state = 'play';
	
		//STOP THE GAME
		setFrameRate('pause');

		//RESET PAC-MANS POSITION
		pacman.reset();
		//REDRAW PACMAN
		drawPacman();
		
		//RESET GHOSTS
		ghosts = [];
		window.setTimeout(spawnGhosts, 3000);
		
		//DRAW FIRST FRAME
		draw();
		
		//RESET DIRECTION
		direction = RIGHT;
		
		//SHOW READY SET GO
		updateGetReadySplash();

		//SET FRAME RATE AND START DRAW LOOP
		//wait for 3 seconds for the updateGetReadySplash to finish - is there a better way of doing this?
		//can I bind an event listener to the end of the function?
		window.setTimeout(function(){ 
			setFrameRate('fast'); 
		}, 3000);
		
		//RESET GAME TIMER
		//this will be used to dynamically update the ghosts AI as the level progresses
		//so the ghosts start off in atHome AI, then update as soon as they all leave the ghosthouse, closing the ghost house and changing AI to chaser
		//then as the level progresses they will swap between scatter and chase
		
	}
	
	//CALL THIS TO DISPLAY GAME OVER
	function gameOver()
	{
		//STOP REPEATER
		setFrameRate('pause');
		//SET GAME STATE
		state = 'gameOver';
		//DISPLAY GAME OVER DIV
		document.getElementById('gameOverSplash').style.display = 'block';
		//to-do finish this by putting in the right data
		document.getElementById('gameOverText').innerHTML = 'You died! You reached level X, scored ' + score + ' points and were playing for X seconds.';
	}
	
	//--
	
	//EASTER EGG FUNCTION
	function playEasterEgg(egg)
	{
		switch(egg){
			case 'rotate':
				if(easterEgg == 'rotating'){
					document.getElementById('game').classList.remove('rotate');
					easterEgg = '';
				}else{
					document.getElementById('game').classList.add('rotate');
					easterEgg = 'rotating';
				}
			break;
		}
	}
	
	//UPDATES THE SCORE
	function updateScore(points)
	{
		score += points;
		document.getElementById('scoreCounter').innerHTML = score;
	}
	
	//CREATES A SPLASH SCREEN THAT DISPLAYS GAME OVER
	function updateLivesCounter(lives)
	{
		livesString = '';
		for(i = 0; i < lives; i++){
			livesString += '&#10084;';
		}
		document.getElementById('livesCounter').innerHTML = livesString;
	}
	
	//CREATES A SPLASH SCREEN THAT DISPLAYS 'READY, SET, GO' OVER TIME, THEN HIDES THE DIV
	function updateGetReadySplash()
	{
		switch(getReadySplashState){
			case 'hidden':
				document.getElementById("getReadySplash").style.display = 'block';
				document.getElementById("ready").style.display = 'block';
				document.getElementById("set").style.display = 'none';
				document.getElementById("go").style.display = 'none';
				getReadySplashState = 'ready';
				window.setTimeout(updateGetReadySplash, 1000);
			break;
			case 'ready':
				document.getElementById("ready").style.display = 'none';
				document.getElementById("set").style.display = 'block';
				getReadySplashState = 'set';
				window.setTimeout(updateGetReadySplash, 1000);
			break;
			case 'set':
				document.getElementById("set").style.display = 'none';
				document.getElementById("go").style.display = 'block';
				getReadySplashState = 'go';
				window.setTimeout(updateGetReadySplash, 1000);
			break;
			case 'go':
				document.getElementById("go").style.display = 'none';
				document.getElementById("getReadySplash").style.display = 'none';
				getReadySplashState = 'hidden';
			break;
		}
	}
	
	//--	
	
	//RUN
	//newGame();
	
	//start game to save button press while developing
	//startGame();
	
</script>